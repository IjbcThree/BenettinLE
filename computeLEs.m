function [ tSpanLEs , LEs , svdIterations ] = computeLEs ( extOde , initPoint , tStep , ...
 nFactors , LEsTol , odeSolverOptions )
 % This MATLAB function implements the numerical procudure to computate
 % finite - time Lyapunov exponents along the trajetory with certain initial point
 % and on the certain time interval for the dynamical system generated by ODE .
 %
 % This function is based on the algorithm , described in:
 % Kuznetsov , N.V., Leonov , G.A., Mokaev , T.N. et al.
 % Finite - time Lyapunov dimension and hidden attractor of the Rabinovich system .
 % Nonlinear Dyn 92, 267?285 (2018) doi :10.1007/ s11071 -018 -4054 - z
 %
 % Parameters :
 % extOde - extended ODE system ( system of ODEs + var . eq .);
 % initPoint - initial point ;
 % tStep - time - step in the factorization procedure ;
 % nFactors - number of factor matrices in the factorization procedure ;
 % LEsTol - tolerance between two successive iterations in the product SVD algoritm ;
 % odeSolverOptions - solver options ( default solver = ode45 );

 % Time span corresponding to LEs :
 tSpanLEs = tStep : tStep : tStep * nFactors ;

 % Dimension of the ODE :
 dimOde = length ( initPoint );

 % Dimension of the extended ODE (ODE + Var . Eq .):
dimExtOde = dimOde * ( dimOde + 1);
 % traj = zeros ( nFactors , dimOde );
 
initFundMatrix = eye ( dimOde );

initCond = [ initPoint(:) ; initFundMatrix(:) ];

 fundMat = zeros ( dimOde , dimOde , nFactors );

 % Main loop : factorization of the fundamental matrix
 for iFactor = 1 : nFactors
     [~, extOdeSolution ] = ode45 ( extOde , [0, tStep ], initCond , odeSolverOptions );

    fundMat (:, :, nFactors - iFactor +1) = reshape (...
                            extOdeSolution (end , ( dimOde + 1) : dimExtOde ), ...
                                                                    dimOde , dimOde );

     currInitPoint = extOdeSolution (end , 1 : dimOde );

     currInitFundMatrix = eye ( dimOde );

     initCond = [currInitPoint(:) ; currInitFundMatrix(:) ];
 end

 LEs = zeros ( nFactors , dimOde );
 svdIterations = zeros ( nFactors , 1);

 for iFactor = 1 : nFactors

    currFactorization = fundMat (:, :, nFactors - iFactor +1 : nFactors );

    currSvdIteration = 1; LEsWithinTol = false ;

    while ~ LEsWithinTol

        % Save current iteration number :
        svdIterations ( iFactor ) = currSvdIteration ;

        % Calculate current LEs approximation :
        [~, R] = treppeniterationQR ( currFactorization );

        for jFactor = 1 : iFactor
            currFactorization (:, :, jFactor ) = R(:, :, iFactor - jFactor +1)';
        end

        accumLEs = zeros (1, dimOde );

        for jFactor = 1 : iFactor
            accumLEs = accumLEs + log ( diag ( currFactorization (:, :, jFactor ))');
        end

        LEs ( iFactor , :) = accumLEs / ( tStep * iFactor );

        % Compare with previous approximation :
        if currSvdIteration > 1
            LEsWithinTol = all (abs (LEs ( iFactor , :) - prevLEs ) < LEsTol );
        end

        % Update
        currSvdIteration = currSvdIteration + 1;
        prevLEs = LEs ( iFactor , :);
    end
 end

 end